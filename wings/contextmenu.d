module wings.contextmenu; // Created on 30-July-2022 06:52 PM

import core.sys.windows.windows;
import std.utf;
import core.sys.windows.commctrl: SetWindowSubclass, RemoveWindowSubclass, DefSubclassProc;

import std.stdio;
import wings.controls: Control;
import wings.fonts: Font;
import wings.enums: MenuType, ControlType;
import wings.menubar: MenuBase, MenuItem, getMenuItem, ParentKind;
import wings.events: EventHandler, EventArgs;
import wings.colors: makeHBRUSH, getClrRef;
import wings.commons: getControl, getMousePoints, getMousePos, getAs, print;

enum wstring cmenuWndClass = "Wings_Cmenu_Msg_Window";

class ContextMenu : MenuBase 
{
    import wings.application: appData;
    this () {
        this.mHandle = CreatePopupMenu();
        this.mWidth = 120;
        this.mHeight = 25;
        this.mRightClick = true;
        this.mFont = new Font("Tahoma", 11);
        this.mDefBgBrush = makeHBRUSH(0xe9ecef);
        this.mHotBgBrush = makeHBRUSH(0x90e0ef);
        this.mBorderBrush = makeHBRUSH(0x0077b6);
        this.mGrayBrush = makeHBRUSH(0xced4da);
        this.mGrayCref = getClrRef(0x979dac);
        if (!mMsgWinRegistered) {
            appData.registerMsgOnlyWindow(cmenuWndClass.ptr, &cmenuWndProc2);
            mMsgWinRegistered = true;
        }
    }

    this(Control parent, string[] menuNames ...) {
        this();
        this.mParent = parent;
        this.setMenuInternal(menuNames);
    }

    this(Control parent) {
        this();
        this.mParent = parent;
    }

    ~this()
    {
        // Just for a safety, although dummy hwnd already be destroyed.
        if (this.mDummyHwnd) DestroyWindow(this.mDummyHwnd);

        /*----------------------------------------------------------
        When context menu dissappers, the backing message-only window
        wil be destroyed. But we will destroy our menu related 
        resources when the whole program ends.
        ------------------------------------------------------------*/
        if (this.mMenus.length > 0) {
            foreach (key; this.mMenus.byKey()) {
                this.mMenus[key].finalize();
            }
        }
        DeleteObject(this.mDefBgBrush);
        DeleteObject(this.mHotBgBrush);
        DeleteObject(this.mBorderBrush);
        DeleteObject(this.mGrayBrush);
        DestroyMenu(this.mHandle);
        // writeln("Context menu dtor worked");
    }

    MenuItem addItem(string item) {
        MenuType mtyp = item == "|" ? MenuType.separator : MenuType.normalMenu;
        MenuItem mi = new MenuItem(item, mtyp, this.mHandle, this.mMenuCount);
        mi.mParentKind = ParentKind.contextMenu;
        this.mMenuCount += 1;
        this.mMenus[item] = mi;
        return mi;
    }

    void addItems(string[] menuNames ...) { this.setMenuInternal(menuNames);}

    package:
        Control mParent;

        void showMenu(LPARAM lpm) 
        {
            this.setDummyWindow(); // Create the message-only window.
            scope(exit) DestroyWindow(this.mDummyHwnd);
            if (!this.mFont.handle) this.mFont.createFontHandle(this.mDummyHwnd);
            if (!this.mCmenuCreated) this.createCmenuHandle();
            if (this.mParent && this.mMenus.length) {
                POINT pt = getMousePos(lpm);
                if (pt.x == -1 && pt.y == -1) {
                    // ContextMenu message generated by keybord shortcut.
                    // So we need to find the mouse position.
                    pt = getMousePoints();
                }
                immutable UINT mBtn = this.mRightClick ? TPM_RIGHTBUTTON : TPM_LEFTBUTTON;
                TrackPopupMenu(this.mHandle, mBtn, pt.x, pt.y, 0, this.mDummyHwnd, null);
            } else {
                throw new Exception("Either parent is null or no menu items added");
            }
        }


        MenuItem getMenuItem(int idNum) {
            foreach (key; this.mMenus.byKey()) {
                auto menu = this.mMenus[key];
                if (menu.mId == idNum) return menu;
            }
            return null;
        }


    EventHandler onMenuShown, onMenuClose;
    private:
        int mWidth, mHeight, mMenuCount;
        bool mRightClick, mCmenuCreated;
        static bool mMsgWinRegistered;
        COLORREF mGrayCref;
        HWND mDummyHwnd;
        HBRUSH mDefBgBrush, mHotBgBrush, mBorderBrush, mGrayBrush;


        void setMenuInternal(string[] menuNames) {
            if (menuNames.length > 0) {
                foreach (name; menuNames) {
                    auto mtyp = name == "|" ? MenuType.separator : MenuType.normalMenu;
                    auto mi = new MenuItem(name, mtyp, this.mHandle, this.mMenuCount);
                    mi.mParentKind = ParentKind.contextMenu;
                    this.mMenuCount += 1;
                    this.mMenus[name] = mi;
                }
            }
        }

        void createCmenuHandle()
        {
            if (this.mMenus.length > 0) {
                foreach (string key; this.mMenus.byKey()) {
                    this.mMenus[key].insertCmenuInternal();
                }
            }
            this.mCmenuCreated = true;
        }

        void setDummyWindow() 
        {
            this.mDummyHwnd = CreateWindowExW(0, cmenuWndClass.ptr, null, 
                                                0, 0, 0, 0, 0, HWND_MESSAGE, 
                                                null, appData.hInstance, null);
            if (this.mDummyHwnd) {
                SetWindowLongPtrW(this.mDummyHwnd, GWLP_USERDATA, (cast(LONG_PTR) cast(void*) this));
                // writeln("dummy message-nly window created");
            } 

        }

} // End of ContextMenu class

enum MenuStyle {
    leftToRight = 0x400,
    rightToLeft = 0x800,
    topToBottom = 0x1000,
    bottomToTop = 0x2000,
    none = 0x4000
}

enum MenuPosition {
    leftAlign,
    topAlign = 0,
    centerAlign = 4,
    rightAlign = 8,
    vCenterAlign = 10,
    bottomAlign = 20
}



extern(Windows)
private LRESULT cmenuWndProc2(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) nothrow
{
    try {
        // print("Cmenu Wndproc rcvd", message);
        switch (message) {
            // case WM_DESTROY:
                // auto cm = getAs!ContextMenu(hWnd);  
                // cm.finalize();        
                // writeln("Cmenu Message only window got WM_DESTROY");
            // break;
            case WM_MEASUREITEM:
                auto cm = getAs!ContextMenu(hWnd);
                auto pmi = cast(LPMEASUREITEMSTRUCT) lParam;
                pmi.itemWidth = UINT(cm.mWidth);
                pmi.itemHeight = UINT(cm.mHeight);
                return 1;
            break;
            case WM_DRAWITEM:
                auto cm = getAs!ContextMenu(hWnd);
                auto dis = cast(LPDRAWITEMSTRUCT) lParam;
                auto mi = getMenuItem(dis.itemData);
                COLORREF txtClrRef = mi.mFgColor.cref;
                if (dis.itemState == 257) {
                    if (mi.mEnabled) {
                        auto rc = RECT(dis.rcItem.left + 4, dis.rcItem.top + 2, dis.rcItem.right, dis.rcItem.bottom - 2);
                        FillRect(dis.hDC, &rc, cm.mHotBgBrush);
                        FrameRect(dis.hDC, &rc, cm.mBorderBrush);
                        txtClrRef = 0x00000000;
                    } else {
                        FillRect(dis.hDC, &dis.rcItem, cm.mGrayBrush);
                        txtClrRef = cm.mGrayCref;
                    }
                } else {
                    FillRect(dis.hDC, &dis.rcItem, cm.mDefBgBrush);
                    if (!mi.mEnabled) txtClrRef = cm.mGrayCref;
                }
                SetBkMode(dis.hDC, 1);
                dis.rcItem.left += 25;
                SelectObject(dis.hDC, cm.mFont.handle);
                SetTextColor(dis.hDC, txtClrRef);
                DrawTextW(dis.hDC, mi.mWideText, -1, &dis.rcItem, DT_LEFT | DT_SINGLELINE | DT_VCENTER);
                return 0;
            break;
            case WM_ENTERMENULOOP: 
                auto cm = getAs!ContextMenu(hWnd);
                if (cm.onMenuShown) cm.onMenuShown(cm.mParent, new EventArgs()); 
            break;
            case WM_EXITMENULOOP: 
                auto cm = getAs!ContextMenu(hWnd);
                if (cm.onMenuClose) cm.onMenuClose(cm.mParent, new EventArgs()); 
            break;
            case WM_MENUSELECT:
                auto cm = getAs!ContextMenu(hWnd);
                immutable int idNum = cast(int) (LOWORD(wParam));
                auto hMenu = cast(HMENU) lParam;
                if (hMenu && idNum > 0) {
                    auto menu = cm.getMenuItem(idNum);
                    if (menu && menu.mEnabled) {
                        if (menu.onFocus) menu.onFocus(menu, new EventArgs());
                    }
                }
            break;
            case WM_COMMAND:
                auto cm = getAs!ContextMenu(hWnd);
                immutable int idNum2 = cast(int)(LOWORD(wParam));
                if (idNum2 > 0) {
                    auto menu = cm.getMenuItem(idNum2);
                    if (menu && menu.mEnabled) {
                        if (menu.onClick) menu.onClick(menu, new EventArgs());
                    }
                }
            break;
            default: break;
        }
    }
    catch (Exception e){}
    return DefWindowProcW(hWnd, message, wParam, lParam);
}