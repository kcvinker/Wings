module wings.contextmenu; // Created on 30-July-2022 06:52 PM

import core.sys.windows.windows;
import std.utf;
import core.sys.windows.commctrl: SetWindowSubclass, RemoveWindowSubclass, DefSubclassProc;

import wings.window: Window;
import wings.controls: Control;
import wings.fonts: Font;
import wings.enums: MenuType, ControlType;
import wings.menubar: MenuBase, MenuItem, getMenuItem, ParentKind;
import wings.events: EventHandler, EventArgs;
import wings.colors: makeHBRUSH, getClrRef;
import wings.commons: appData, getControl, getMousePoints, getMousePos;


class ContextMenu : MenuBase {

    this () {
        this.mHandle = CreatePopupMenu();
        this.mWidth = 120;
        this.mHeight = 25;
        this.mRightClick = true;
        this.mFont = new Font("Tahoma", 11);
        this.mDefBgBrush = makeHBRUSH(0xe9ecef);
        this.mHotBgBrush = makeHBRUSH(0x90e0ef);
        this.mBorderBrush = makeHBRUSH(0x0077b6);
        this.mGrayBrush = makeHBRUSH(0xced4da);
        this.mGrayCref = getClrRef(0x979dac);
    }

    this(Control parent, string[] menuNames ...) {
        this();
        this.mParent = parent;
        this.setMenuInternal(menuNames);
    }

    this(Control parent) {
        this();
        this.mParent = parent;
    }

    MenuItem addItem(string item)
    {
        MenuType mtyp = item == "|" ? MenuType.separator : MenuType.normalMenu;
        MenuItem mi = new MenuItem(item, mtyp, this.mHandle, this.mMenuCount);
        mi.mParentKind = ParentKind.contextMenu;
        this.mMenuCount += 1;
        this.mMenus[item] = mi;
        return mi;
    }

    void addItems(string[] menuNames ...) {
        this.setMenuInternal(menuNames);
    }




    package:
        Control mParent;

        // This function executed at the 'contextMenu' property if each control.
        // 'contextMenu' property will set the parent if it is null.
        void setDummyControl()
        {
            auto pHwnd = isWindow() ? this.mParent.mHandle : this.mParent.mParent.mHandle;
            auto hinst = appData.hInstance;
            this.mDummyHwnd = CreateWindowExW(0, "Button".toUTF16z, null, WS_CHILD, 0, 0, 0, 0, pHwnd, null, hinst, null);
            SetWindowSubclass(this.mDummyHwnd, &cmenuWndProc, UINT_PTR(Control.mSubClassId), this.toDwordPtr);
            Control.mSubClassId += 1;
            if (!this.mFont.handle) this.mFont.createFontHandle(this.mDummyHwnd);
        }

        void showMenu(LPARAM lpm)
        {
            if (!this.mCmenuCreated) this.createCmenuHandle();
            if (this.mParent && this.mMenus.length) {
                POINT pt = getMousePos(lpm);
                if (pt.x == -1 && pt.y == -1) {
                    // ContextMenu message generated by keybord shortcut.
                    // So we need to find the mouse position.
                    pt = getMousePoints();
                }
                immutable UINT mBtn = this.mRightClick ? TPM_RIGHTBUTTON : TPM_LEFTBUTTON;
                TrackPopupMenu(this.mHandle, mBtn, pt.x, pt.y, 0, this.mDummyHwnd, null);
            } else {
                throw new Exception("Either parent is null or no menu items added");
            }
        }


        MenuItem getMenuItem(int idNum)
        {
            foreach (key; this.mMenus.byKey()) {
                auto menu = this.mMenus[key];
                if (menu.mId == idNum) return menu;
            }
            return null;
        }


    EventHandler onMenuShown, onMenuClose;
    private:
        int mWidth, mHeight, mMenuCount;
        bool mRightClick, mCmenuCreated;
        COLORREF mGrayCref;
        HWND mDummyHwnd;

        HBRUSH mDefBgBrush, mHotBgBrush, mBorderBrush, mGrayBrush;

        bool isWindow() {return this.mParent.mControlType == ControlType.window;}
        DWORD_PTR toDwordPtr() {return cast(DWORD_PTR) (cast(void*) this);}

        void setMenuInternal(string[] menuNames)
        {
            if (menuNames.length > 0) {
                foreach (name; menuNames) {
                    auto mtyp = name == "|" ? MenuType.separator : MenuType.normalMenu;
                    auto mi = new MenuItem(name, mtyp, this.mHandle, this.mMenuCount);
                    mi.mParentKind = ParentKind.contextMenu;
                    this.mMenuCount += 1;
                    this.mMenus[name] = mi;
                }
            }
        }

        void createCmenuHandle()
        {
            if (this.mMenus.length > 0) {
                foreach (string key; this.mMenus.byKey()) this.mMenus[key].insertCmenuInternal();
            }
            this.mCmenuCreated = true;
        }

} // End of ContextMenu class

enum MenuStyle {
    leftToRight = 0x400,
    rightToLeft = 0x800,
    topToBottom = 0x1000,
    bottomToTop = 0x2000,
    none = 0x4000
}

enum MenuPosition {
    leftAlign,
    topAlign = 0,
    centerAlign = 4,
    rightAlign = 8,
    vCenterAlign = 10,
    bottomAlign = 20
}

extern(Windows)
private LRESULT cmenuWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, UINT_PTR scID, DWORD_PTR refData)  {
    try {
        ContextMenu cm = getControl!ContextMenu(refData);
        switch (message) {
            case WM_DESTROY :
                DestroyMenu(cm.mHandle);
                RemoveWindowSubclass(hWnd, &cmenuWndProc, scID);
            break;
            case WM_MEASUREITEM:
                auto pmi = cast(LPMEASUREITEMSTRUCT) lParam;
                pmi.itemWidth = UINT(cm.mWidth);
                pmi.itemHeight = UINT(cm.mHeight);
                return 1;
            break;
            case WM_DRAWITEM:
                auto dis = cast(LPDRAWITEMSTRUCT) lParam;
                auto mi = getMenuItem(dis.itemData);
                COLORREF txtClrRef = mi.mFgColor.cref;
                if (dis.itemState == 257) {
                    if (mi.mEnabled) {
                        auto rc = RECT(dis.rcItem.left + 4, dis.rcItem.top + 2, dis.rcItem.right, dis.rcItem.bottom - 2);
                        FillRect(dis.hDC, &rc, cm.mHotBgBrush);
                        FrameRect(dis.hDC, &rc, cm.mBorderBrush);
                        txtClrRef = 0x00000000;
                    } else {
                        FillRect(dis.hDC, &dis.rcItem, cm.mGrayBrush);
                        txtClrRef = cm.mGrayCref;
                    }
                } else {
                    FillRect(dis.hDC, &dis.rcItem, cm.mDefBgBrush);
                    if (!mi.mEnabled) txtClrRef = cm.mGrayCref;
                }
                SetBkMode(dis.hDC, 1);
                dis.rcItem.left += 25;
                SelectObject(dis.hDC, cm.mFont.handle);
                SetTextColor(dis.hDC, txtClrRef);
                DrawTextW(dis.hDC, mi.mWideText, -1, &dis.rcItem, DT_LEFT | DT_SINGLELINE | DT_VCENTER);
                return 0;
            break;
            case WM_ENTERMENULOOP: if (cm.onMenuShown) cm.onMenuShown(cm.mParent, new EventArgs()); break;
            case WM_EXITMENULOOP: if (cm.onMenuClose) cm.onMenuClose(cm.mParent, new EventArgs()); break;
            case WM_MENUSELECT:
                immutable int idNum = cast(int) (LOWORD(wParam));
                auto hMenu = cast(HMENU) lParam;
                if (hMenu && idNum > 0) {
                    auto menu = cm.getMenuItem(idNum);
                    if (menu && menu.mEnabled) {
                        if (menu.onFocus) menu.onFocus(menu, new EventArgs());
                    }
                }
            break;
            case WM_COMMAND:
                immutable int idNum2 = cast(int)(LOWORD(wParam));
                if (idNum2 > 0) {
                    auto menu = cm.getMenuItem(idNum2);
                    if (menu && menu.mEnabled) {
                        if (menu.onClick) menu.onClick(menu, new EventArgs());
                    }
                }
            break;
            default : return DefSubclassProc(hWnd, message, wParam, lParam); break;
        }

    }
    catch (Exception e) {}
    return DefSubclassProc(hWnd, message, wParam, lParam);
}